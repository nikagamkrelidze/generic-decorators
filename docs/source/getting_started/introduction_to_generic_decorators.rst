Introduction to Generic Decorators
==================================

Writing your first Interceptor
------------------------------

**Generic Decorators** library allows you to generate decorators during compile time using `Roslyn's Source Generators <https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/>`_, based on an interceptor
and an interface 

When we are talking about *decorating* some method of a type (in our case of an *interface*, because **Generic Decorators** can **only be used to produce decorators for interfaces**, not abstract classes), we are talking
about performing some actions before and/or after the execution of the given method, also possibly interacting with the result of the execution in some way. In any case, such logic can be encapsulated into a component known
as *an interceptor*. It is an interceptor, in the sense that if the decorated version of the method is invoked, the execution flow intercepted and controlled by that component.

The Generic Decorators library tries to provide means for writing all kinds of decorators and achieves it through providing several kinds of interceptors which are shipped with the nuget package. The interceptors are grouped
into categories, based on whether or not they give you the access to the arguments of the method that they are decorating. There are following categories of interceptors defined by Generic Decorators library

#. Simple Interceptors -- they are simple in the sense that they don't provide any access to the parameters of the underlying methods that they are decorating.

#. TBA.

In this section we will use simple interceptors as an example for a gentle introduction. The `cookbook <TBA>`_ will provide more examples of how to use different kinds of interceptors to achieve different kinds of access
to the arguments passed to the underlying methods.

In order to implement a simple interceptor that the Generic Decorators library would be able to use for decorating arbitrary interfaces with it, you need to inherit from a class `SimpleInterceptor`, which is defined and
shipped with `GenericDecorators.Extensions.Core <TBA>`_ nuget package. In the following example we will define an interceptor that simply meters the execution time of any method that returns ``void``:

.. sourcecode:: csharp
    :linenos:
    
    using GenericDecorators.Extensions.Core.BaseInterceptors;
    using System.Diagnostics;

    public class MeteringInterceptor : SimpleInterceptor
    {
        public override void Process<TMethodContext>(
            in TMethodContext methodContext,
            Action<TMethodContext> internalImplementation)
        {
            var sw = new Stopwatch();

            internalImplementation(methodContext);

            sw.Stop();
            Console.WriteLine($"Elapsed time: {sw.ElapsedMilliseconds} ms");
        }
    }

Before we apply it to any interface to get a decorated version of that interface, let's take a closer look at what's happening in the code snippet above.

We are overriding some predefined ``Process`` method. This method is defined in the ``SimpleInterceptor`` and provides you with the ability to define what is going to happen during decoration, as well as how your decorating
logic should interact with the underlying, "real" implementation of the method that it's being used to decorate.

As you can see, the interceptor creates an instance of ``Stopwatch``, then calls the underlying implementation of the method that it's decorating, which is represented by an action ``internalImplementation``.
The action receives an instance of some generic type ``TMethodContext``, which, together with the ``internalImplementation`` action itself, is passed to the ``Process`` as a parameter.

During the invocation, the ``methodContext`` will contain everything that is required
for the internal implementation to run correctly - it will be instantiated by the decorator generated by the library and will contain the reference to the underlying implementation and the arguments that need to be handed
over to the underlying implementation. Wrapping all of this into an ``Action`` and passing it to the ``Process`` gives control over when and how the internal implementation is invoked to you, the user of the library.
The definition of the actual ``TMethodContext`` will also be generated by the library and will vary from method to method. If you are interested, it is possible to inspect the type definitions for those contexts,
they are generated as nested types within the decorator type.

