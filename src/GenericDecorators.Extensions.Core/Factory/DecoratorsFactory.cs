using System;
using System.Collections.Generic;
using System.Linq;

namespace GenericDecorators.Extensions.Core.Factory;

/// <summary>
/// A singleton that provides methods to instantiate decorators.
/// The actual implementations of instantiators are generated by the library and injected via <see cref="Instance"/>.
/// </summary>
public class DecoratorsFactory
{
    static DecoratorsFactory()
    {
        var assemblies = AppDomain.CurrentDomain.GetAssemblies();

        Instance = new DecoratorsFactory(assemblies.SelectMany(assembly => assembly.InstantiateImplementationsOf<ISimpleDecoratorInstantiator>()).ToArray());
    }

    /// <summary>
    /// Gets the singleton instance of the factory, injected by the library.
    /// </summary>
    public static DecoratorsFactory Instance { get; private set; }

    private readonly ISimpleDecoratorInstantiator[] _simpleDecoratorInstantiators;

    /// <summary>
    /// Initializes a new instance of the <see cref="DecoratorsFactory"/> class.
    /// </summary>
    /// <param name="simpleDecoratorInstantiators">Instantitators for simple decorators as generated by the library.</param>
    public DecoratorsFactory(
        ISimpleDecoratorInstantiator[] simpleDecoratorInstantiators)
    {
        _simpleDecoratorInstantiators = simpleDecoratorInstantiators;
    }

    /// <summary>
    /// Used to instantiate a simple decorator using instantiator generated by the library and injected via <see cref="DecoratorsFactory"/>.
    /// </summary>
    /// <typeparam name="TInterface">The interface to be decorated.</typeparam>
    /// <typeparam name="TInterceptor">The interceptor to be used.</typeparam>
    /// <param name="underlyingImplementation">The underlying implementation of the interface.</param>
    /// <param name="applicableMembers">The members to be intercepted.</param>
    /// <param name="interceptor">The interceptor to be used for interception.</param>
    /// <returns>The decorated interface.</returns>
    public TInterface? InstantiateSimpleDecorator<
        TInterface,
        TInterceptor>(
            TInterface underlyingImplementation,
            HashSet<string>? applicableMembers,
            TInterceptor interceptor)
        where TInterface : class
    {
        for (int i = 0; i < _simpleDecoratorInstantiators.Length; i++)
        {
            var decorator = _simpleDecoratorInstantiators[i]
                .Instantiate<TInterface, TInterceptor>(
                    underlyingImplementation,
                    applicableMembers,
                    interceptor);

            if (decorator != null)
            {
                return decorator;
            }
        }

        return null;
    }
}
